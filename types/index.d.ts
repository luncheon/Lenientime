export interface LenientimeLike {
    readonly h?: string | number;
    readonly hour?: string | number;
    readonly hours?: string | number;
    readonly m?: string | number;
    readonly minute?: string | number;
    readonly minutes?: string | number;
    readonly s?: string | number;
    readonly second?: string | number;
    readonly seconds?: string | number;
    readonly S?: string | number;
    readonly ms?: string | number;
    readonly millisecond?: string | number;
    readonly milliseconds?: string | number;
    readonly am?: boolean;
    readonly pm?: boolean;
    readonly a?: 'am' | 'pm' | 'AM' | 'PM' | '--';
}
export declare type LenientimeParsable = Lenientime | LenientimeLike | number | number[] | string;
export default class Lenientime implements LenientimeLike {
    private _totalMilliseconds;
    static INVALID: Lenientime;
    static ZERO: Lenientime;
    static of(source: LenientimeParsable): Lenientime;
    static now(): Lenientime;
    static min(...times: LenientimeParsable[]): Lenientime;
    static max(...times: LenientimeParsable[]): Lenientime;
    static reduce<TLenientimeArrayLike extends ArrayLike<LenientimeParsable>>(source: TLenientimeArrayLike, callback: (previousValue: Lenientime, currentValue: Lenientime, currentIndex: number, source: TLenientimeArrayLike) => Lenientime, initialValue?: Lenientime): Lenientime;
    static padStart(source: any, maxLength: number, pad?: string): any;
    static padEnd(source: any, maxLength: number, pad?: string): any;
    static _pad(padLength: number, pad?: string): string;
    static firstNumberOf(...args: (any | undefined)[]): number | undefined;
    static _totalMillisecondsOf(time: LenientimeParsable): number;
    static _normalizeMillisecondsInOneDay(milliseconds: number): number;
    static parse(s: string): Lenientime;
    private constructor();
    readonly hour: number;
    readonly hour12: number;
    readonly minute: number;
    readonly second: number;
    readonly millisecond: number;
    readonly am: boolean;
    readonly pm: boolean;
    readonly hours: number;
    readonly hours12: number;
    readonly minutes: number;
    readonly seconds: number;
    readonly milliseconds: number;
    readonly H: string;
    readonly h: string;
    readonly k: string;
    readonly m: string;
    readonly s: string;
    readonly S: string;
    readonly SS: string;
    readonly SSS: string;
    readonly a: string;
    readonly A: string;
    readonly aa: string;
    readonly AA: string;
    readonly HH: any;
    readonly _H: any;
    readonly hh: any;
    readonly _h: any;
    readonly kk: any;
    readonly _k: any;
    readonly mm: any;
    readonly _m: any;
    readonly ss: any;
    readonly _s: any;
    readonly HHmm: string;
    readonly HHmmss: string;
    readonly HHmmssSSS: string;
    readonly totalMilliseconds: number;
    readonly totalSeconds: number;
    readonly totalMinutes: number;
    readonly valid: boolean;
    readonly invalid: boolean;
    readonly startOfHour: Lenientime;
    readonly startOfMinute: Lenientime;
    readonly startOfSecond: Lenientime;
    startOf(unit: 'hour' | 'minute' | 'second'): Lenientime;
    toString(): string;
    format(template: string): string;
    with(time: LenientimeLike): Lenientime;
    plus(time: LenientimeParsable): Lenientime;
    minus(time: LenientimeParsable): Lenientime;
    equals(another: LenientimeParsable): boolean;
    compareTo(another: LenientimeParsable): number;
    isBefore(another: LenientimeParsable): boolean;
    isBeforeOrEqual(another: LenientimeParsable): boolean;
    isAfter(another: LenientimeParsable): boolean;
    isAfterOrEqual(another: LenientimeParsable): boolean;
    isBetweenExclusive(start: LenientimeParsable, end: LenientimeParsable): boolean;
    isBetweenInclusive(min: LenientimeParsable, max: LenientimeParsable): boolean;
}
